---
title: "@import и глобальные встроенные функции"
icon: lucide/newspaper
---

> Изначально Sass использовал правила `@import` для загрузки других файлов с единым глобальным пространством имён, при этом все встроенные функции также были доступны глобально. Мы объявляем устаревшими как правила Sass `@import`, так и глобальные встроенные функции теперь, когда модульная система (правила `@use` и `@forward`) доступна уже несколько лет.

`@import` вызывает множество проблем, требуя ручного добавления пространств имён к элементам Sass во избежание конфликтов, замедляя компиляцию, когда один и тот же файл импортируется более одного раза, и делая очень сложным как для людей, так и для инструментов определение того, откуда берется та или иная переменная, миксин или функция.

Модульная система решает эти проблемы и приводит модульность Sass в соответствие с лучшими практиками других современных языков, но мы не можем получить все её преимущества, пока `@import` остается в языке.

`@import` теперь объявлен устаревшим начиная с Dart Sass 1.80.0. Кроме того, мы также объявляем устаревшими глобальные версии встроенных функций Sass, которые доступны в модулях `sass:`.

## Переходный период {#transition-period}

Правила Sass `@import` и вызовы глобальных встроенных функций теперь выдают предупреждения об устаревании. Хотя Dart Sass 2.0.0 будет выпущен в ближайшее время с различными более мелкими критическими изменениями, мы не ожидаем удалить правила Sass `@import` или глобальные встроенные функции до Dart Sass 3.0.0, который будет выпущен не ранее чем через два года после Dart Sass 1.80.0.

В конечном итоге все правила `@import` будут рассматриваться как [чистые CSS `@import`](../at-rules/import/#plain-css-imports), вероятно, после промежуточного периода, когда всё, что раньше было Sass `@import`, будет вызывать ошибку.

## Автоматическая миграция {#automatic-migration}

Вы можете использовать [мигратор Sass](https://github.com/sass/migrator#readme) для автоматического обновления ваших таблиц стилей для использования модульной системы.

```sh
$ npm install -g sass-migrator
$ sass-migrator module --migrate-deps your-entrypoint.scss
```

Если вы хотите отказаться от глобальных встроенных функций, но ещё не готовы полностью мигрировать ваши правила `@import`, вы можете передать флаг `--built-in-only`, чтобы мигрировать функции, оставив правила `@import` без изменений.

## Рецепты миграции {#migration-recipes}

### Вложенные импорты {#nested-imports}

Хотя `@import` может использоваться внутри CSS-правил, `@use` должен быть написан на верхнем уровне файла (это потому, что CSS каждого модуля с `@use` включается в вывод только один раз, поэтому не имело бы смысла разрешать его как во вложенном контексте, так и на верхнем уровне). Существует два способа мигрировать вложенные `@import` на модульную систему:

1. Рекомендуемый способ, который требует немного больше предварительных усилий, — обернуть весь CSS, выдаваемый вашими вложенными модулями, в [миксины](../at-rules/mixin/) и использовать `@include` для этих миксинов во вложенном контексте. Это соответствует способу работы большинства других языков программирования, где каждый файл определяет функцию или класс, который вызывается файлами, использующими его, и это делает совершенно ясным, как именно вы ожидаете использовать этот файл. Это также облегчает добавление конфигурации, поскольку вы можете просто передавать параметры или даже [блоки `@content`](../at-rules/mixin/#content-blocks) в миксин.

2. Более прямой перевод — использовать [миксин `meta.load-css()`](../modules/meta/#load-css) для непосредственной загрузки CSS модуля там, где вы хотите его использовать. Это уместно, когда у вас нет контроля над загружаемым файлом для создания обёртки миксина. Обратите внимание, что `meta.load-css()` полностью компилирует CSS перед выполнением любого вложения, поэтому любые [родительские селекторы](../style-rules/parent-selector/) не «увидят» правила за пределами вызова `meta.load-css()`.

### Настраиваемые темы {#configured-themes}

Паттерн, который люди иногда используют с `@import`, — это наличие библиотеки компонентов, полной фрагментов, которые все используют одни и те же переменные без явной их загрузки, а затем наличие нескольких различных «тематических» точек входа, которые определяют различные значения для этих переменных, чтобы обеспечить различные визуальные темы. Они могут либо определять переменные напрямую, либо переопределять значения по умолчанию базового фрагмента темы. В качестве упрощённого примера:

<div class="grid" markdown>

=== "SCSS"

    ```scss title="components/_button.scss"
    button {
      color: $text-color;
      background-color: $background-color;
    }
    ```
    ```scss title="_theme.scss"
    $text-color: black !default;
    $background-color: white !default;
    ```
    ```scss title="dark.scss"
    $text-color: white;
    $background-color: black;
    @import "theme";

    @import "components/button";
    // Здесь обычно импортируются дополнительные компоненты.
    ```

=== "Sass"

    ```sass title="components/_button.scss"
    button
      color: $text-color
      background-color: $background-color
    ```
    ```sass title="_theme.sass"
    $text-color: black
    $background-color: white
    ```
    ```sass title="dark.sass"
    $text-color: white
    $background-color: black
    @import "theme"

    @import "components/button"
    // Здесь обычно импортируются дополнительные компоненты.
    ```

```css title="CSS"
button {
  color: white;
  background-color: black;
}
```

</div>

В модульной системе фрагменты компонентов должны явно ссылаться на переменные, которые они используют. Но это не означает, что такой вид оформления не работает! Поскольку использование одного и того же модуля несколько раз с помощью `@use` всегда использует одну и ту же конфигурацию, если вы настроите её один раз в точке входа, все остальные использования увидят эту конфигурацию:

<div class="grid" markdown>

=== "SCSS"

    ```scss title="components/_button.scss"
    @use "../theme";

    button {
      color: theme.$text-color;
      background-color: theme.$background-color;
    }
    ```
    ```scss title="_theme.scss"
    $text-color: black !default;
    $background-color: white !default;
    ```
    ```scss title="dark.scss"
    @use "theme" with (
      $text-color: white,
      $background-color: black,
    );

    @use "components/button";
    // Здесь обычно импортируются дополнительные компоненты.
    ```

=== "Sass"

    ```sass title="components/_button.scss"
    @use "../theme"

    button
      color: theme.$text-color
      background-color: theme.$background-color
    ```
    ```sass title="_theme.sass"
    $text-color: black !default
    $background-color: white !default
    ```
    ```sass title="dark.sass"
    @use "theme" with (
      $text-color: white,
      $background-color: black,
    )

    @use "components/button"
    // Здесь обычно импортируются дополнительные компоненты.
    ```

```css title="CSS"
button {
  color: white;
  background-color: black;
}
```

</div>

## Можно ли отключить предупреждения? {#can-i-silence-the-warnings}

Sass предоставляет мощный набор опций для управления тем, какие предупреждения об устаревании вы видите и когда.

### Краткий и подробный режим {#terse-and-verbose-mode}

По умолчанию Sass работает в кратком режиме, где он будет выводить каждый тип предупреждения об устаревании только пять раз, прежде чем отключит дополнительные предупреждения. Это помогает гарантировать, что пользователи знают, когда им нужно быть в курсе предстоящего критического изменения, не создавая при этом огромного количества шума в консоли.

Если вы запустите Sass в подробном режиме, он будет выводить *каждое* предупреждение об устаревании, с которым столкнется. Это может быть полезно для отслеживания оставшейся работы, которую необходимо выполнить при исправлении устареваний. Вы можете включить подробный режим, используя [флаг `--verbose`](../cli/dart-sass/#verbose) в командной строке, или [опцию `verbose`](https://sass-lang.com/documentation/js-api/interfaces/Options/#verbose) в JavaScript API.

!!! tip "Совет"

    При запуске из [JS API](https://sass-lang.com/documentation/js-api/) Sass не делится никакой информацией между компиляциями, поэтому по умолчанию он будет выводить пять предупреждений для *каждой таблицы стилей*, которая компилируется. Однако вы можете это исправить, написав (или попросив автора плагина Sass вашего любимого фреймворка написать) [пользовательский `Logger`](https://sass-lang.com/documentation/js-api/interfaces/Logger-1/), который выводит только пять ошибок на каждое устаревание и может использоваться совместно для нескольких компиляций.

### Отключение устареваний в зависимостях {#silencing-deprecations-in-dependencies}

Иногда ваши зависимости имеют предупреждения об устаревании, с которыми вы ничего не можете поделать. Вы можете отключить предупреждения об устаревании из зависимостей, продолжая при этом выводить их для вашего приложения, используя [флаг `--quiet-deps`](../cli/dart-sass/#quiet-deps) в командной строке, или [опцию `quietDeps`](https://sass-lang.com/documentation/js-api/interfaces/Options/#quietDeps) в JavaScript API.

Для целей этого флага «зависимость» — это любая таблица стилей, которая не является просто серией относительных загрузок из входной таблицы стилей. Это означает всё, что поступает из пути загрузки, и большинство таблиц стилей, загруженных через пользовательские импортеры.

### Отключение конкретных устареваний {#silencing-specific-deprecations}

Если вы знаете, что одно конкретное устаревание не является для вас проблемой, вы можете отключить предупреждения для этого конкретного устаревания, используя [флаг `--silence-deprecation`](../cli/dart-sass/#silence-deprecation) в командной строке, или [опцию `silenceDeprecations`](https://sass-lang.com/documentation/js-api/interfaces/Options/#silenceDeprecations) в JavaScript API.

!!! note "Примечание"

    Хотя устаревания для `@import` и глобальных встроенных функций выпускаются вместе, и мы ожидаем, что обе функции будут удалены одновременно (в Dart Sass 3.0.0), они считаются отдельными устареваниями для целей API. Если вы хотите отключить как предупреждения об устаревании `@import`, так и предупреждения об устаревании глобальных встроенных функций, вам нужно будет передать как `import`, так и `global-builtin` в `--silence-deprecation`/`silenceDeprecations`.
