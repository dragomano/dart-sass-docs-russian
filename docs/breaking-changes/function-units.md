---
title: Строгие единицы измерения функций
icon: lucide/newspaper
---

> Различные встроенные функции станут более строгими в отношении того, какие единицы измерения они допускают, и будут обрабатывать эти единицы более последовательно. Это делает Sass более совместимым со спецификацией CSS и помогает быстрее выявлять ошибки.

## Оттенок {#hue}

При указании оттенка цвета CSS допускает любую [единицу измерения угла](https://drafts.csswg.org/css-values-4/#angles) (`deg`, `grad`, `rad` или `turn`). Он также допускает число без единицы измерения, которое интерпретируется как `deg`. Исторически Sass допускал *любую* единицу измерения и интерпретировал её как `deg`. Это особенно проблематично, потому что это означало, что допустимое CSS-выражение `hsl(0.5turn, 100%, 50%)` было бы разрешено Sass, но интерпретировано совершенно неправильно.

Чтобы исправить эту проблему и привести Sass в соответствие со спецификацией CSS, мы вносим изменения в несколько этапов:

### Фаза 1 {#phase-1}

Сначала Sass просто выдавал предупреждение об устаревании, если вы передавали число с единицей измерения, отличной от `deg`, в качестве оттенка в любую функцию. Передача числа без единицы измерения по-прежнему разрешена.

### Фаза 2 {#phase-2}

Затем мы изменили способ обработки единиц измерения угла для параметров оттенка в соответствии со спецификацией CSS. Это означает, что числа с единицами `grad`, `rad` или `turn` будут преобразованы в `deg`: `0.5turn` будет преобразовано в `180deg`, `100grad` будет преобразовано в `90deg` и так далее.

Поскольку это изменение необходимо для сохранения совместимости с CSS, в соответствии с [политикой совместимости Dart Sass](https://github.com/sass/dart-sass#compatibility-policy) оно было сделано только с увеличением минорной версии. Однако оно изменяет как можно меньше поведения, чтобы гарантировать, что Sass интерпретирует весь допустимый CSS в соответствии со спецификацией CSS.

### Фаза 3 {#phase-3}

Наконец, в Dart Sass 2.0.0 функции для работы с цветом будут выдавать ошибки, если им передан параметр оттенка с единицей измерения, не являющейся единицей угла. Оттенки без единиц измерения по-прежнему будут разрешены.

## Насыщенность и яркость {#saturation-and-lightness}

При указании насыщенности и яркости HSL-цвета CSS допускает только единицы `%`. Даже числа без единиц измерения не разрешены (в отличие от оттенка). Исторически Sass допускал *любую* единицу измерения и интерпретировал её как `%`. Вы могли даже написать `hsl(0, 100px, 50s)`, и Sass вернул бы цвет `red`.

Чтобы исправить эту проблему и привести Sass в соответствие со спецификацией CSS, мы вносим изменения в два этапа:

### Фаза 1 {#phase-1-1}

В настоящее время Sass просто выдает предупреждение об устаревании, если вы передаете число без единицы измерения или с единицей измерения, отличной от `%`, в качестве яркости или насыщенности в любую функцию.

### Фаза 2 {#phase-2-1}

В Dart Sass 2.0.0 функции для работы с цветом будут выдавать ошибки, если им передан параметр насыщенности или яркости без единицы измерения или с единицей, отличной от `%`.

## Альфа {#alpha}

При указании альфа-значения цвета CSS (согласно спецификации [CSS Color 4](https://www.w3.org/TR/css-color-4/#typedef-alpha-value)) допускает либо значения без единиц измерения от 0 до 1, либо значения `%` от `0%` до `100%`. В большинстве случаев Sass следует этому поведению, но функции `color.adjust()` и `color.change()` исторически допускали *любую* единицу измерения и интерпретировали её как безразмерную. Вы могли даже написать `color.change(red, $alpha: 1%)`, и Sass вернул бы непрозрачный цвет `red`.

Чтобы исправить эту проблему и привести Sass в соответствие со спецификацией CSS, мы вносим изменения в три этапа:

### Фаза 1 {#phase-1-2}

В настоящее время Sass просто выдает предупреждение об устаревании, если вы передаете число с любой единицей измерения, включая `%`, в качестве альфа-значения в `color.change()` или `color.adjust()`.

### Фаза 2 {#phase-2-2}

Затем мы изменим способ обработки единиц `%` для аргумента альфа в `color.change()` и `color.adjust()`. Альфа-значения с единицей `%` будут разделены на `100%`, преобразуя их в безразмерные числа от 0 до 1.

Поскольку это изменение является исправлением ошибки, которое улучшает согласованность с другими функциями Sass, оно будет сделано только с увеличением минорной версии. Оно будет изменено минимум через три месяца после выпуска Фазы 1, чтобы дать пользователям время скорректировать свой код и избежать ошибки.

### Фаза 3 {#phase-2-3}

Наконец, в Dart Sass 2.0.0 `color.change()` и `color.adjust()` будут выдавать ошибки, если им передан параметр альфа с единицей измерения, отличной от `%`. Альфа-значения без единиц измерения по-прежнему будут разрешены.

## `math.random()`

[Функция `math.random()`](../modules/math#random) исторически игнорировала единицы измерения в `$limit` и возвращала значение без единиц измерения. Например, `math.random(100px)` отбрасывал `px` и возвращал значение типа `42`.

Будущая версия Sass перестанет игнорировать единицы измерения для аргумента `$limit` и будет возвращать случайное целое число с теми же единицами измерения.

=== "SCSS"

    ```scss
    @use "sass:math";

    // Будущий Sass, пока не работает!
    @debug math.random(100px); // 42px
    ```

=== "SASS"

    ```sass
    @use "sass:math"

    // Будущий Sass, пока не работает!
    @debug math.random(100px) // 42px
    ```

### Фаза 1 {#phase-1-3}

В настоящее время Sass выводит предупреждение об устаревании, если вы передаёте `$limit` с единицами измерения в `math.random()`.

### Фаза 2 {#phase-2-3}

В Dart Sass 2.0.0 передача числа `$limit` с единицами измерения будет ошибкой.

### Фаза 3 {#phase-3-3}

В одном из минорных релизов после Dart Sass 2.0.0 передача числа `$limit` с единицами измерения в функцию `math.random()` снова будет разрешена. Она будет возвращать случайное целое число с теми же единицами измерения, что и у `$limit`, вместо числа без единиц.

## Вес {#weight}

Функции [`color.mix()`](../modules/color#mix) и [`color.invert()`](../modules/color#invert) исторически игнорировали единицы измерения в аргументах `$weight`, хотя концептуально этот аргумент представляет собой процент. В будущей версии Sass потребуется единица измерения `%`.

### Фаза 1 {#phase-1-4}

В настоящее время Sass выводит предупреждение об устаревании, если вы передаёте `$weight` без единиц измерения или с единицами, отличными от `%`, в `color.mix()` или `color.invert()`.

### Фаза 2 {#phase-2-4}

В Dart Sass 2.0.0 `color.mix()` и `color.invert()` будут выдавать ошибки, если им передан `$weight` без единицы измерения или с единицей, отличной от `%`.

## Индекс {#index}

Функции [`list.nth()`](../modules/list#nth) и [`list.set-nth()`](../modules/list#set-nth) исторически игнорировали единицы измерения в своих аргументах `$n`. В будущей версии Sass любые единицы измерения будут запрещены.

### Фаза 1 {#phase-1-5}

В настоящее время Sass выводит предупреждение об устаревании, если вы передаёте индекс `$n` с единицами измерения в `list.nth()` или `list.set-nth()`.

### Фаза 2 {#phase-2-5}

В Dart Sass 2.0.0 `list.nth()` и `list.set-nth()` будут выдавать ошибки, если им передан индекс `$n` с единицей измерения.

## Можно ли отключить предупреждения? {#can-i-silence-the-warnings}

Sass предоставляет мощный набор опций для управления тем, какие предупреждения об устаревании вы видите и когда.

### Краткий и подробный режим {#terse-and-verbose-mode}

По умолчанию Sass работает в кратком режиме, где он будет выводить каждый тип предупреждения об устаревании только пять раз, прежде чем отключит дополнительные предупреждения. Это помогает гарантировать, что пользователи знают, когда им нужно быть в курсе предстоящего критического изменения, не создавая при этом огромного количества шума в консоли.

Если вы запустите Sass в подробном режиме, он будет выводить *каждое* предупреждение об устаревании, с которым столкнется. Это может быть полезно для отслеживания оставшейся работы, которую необходимо выполнить при исправлении устареваний. Вы можете включить подробный режим, используя [флаг `--verbose`](../cli/dart-sass/#verbose) в командной строке, или [опцию `verbose`](https://sass-lang.com/documentation/js-api/interfaces/Options/#verbose) в JavaScript API.

!!! tip "Совет"

    При запуске из [JS API](https://sass-lang.com/documentation/js-api/) Sass не делится никакой информацией между компиляциями, поэтому по умолчанию он будет выводить пять предупреждений для *каждой таблицы стилей*, которая компилируется. Однако вы можете это исправить, написав (или попросив автора плагина Sass вашего любимого фреймворка написать) [пользовательский `Logger`](https://sass-lang.com/documentation/js-api/interfaces/Logger-1/), который выводит только пять ошибок на каждое устаревание и может использоваться совместно для нескольких компиляций.

### Отключение устареваний в зависимостях {#silencing-deprecations-in-dependencies}

Иногда ваши зависимости имеют предупреждения об устаревании, с которыми вы ничего не можете поделать. Вы можете отключить предупреждения об устаревании из зависимостей, продолжая при этом выводить их для вашего приложения, используя [флаг `--quiet-deps`](../cli/dart-sass/#quiet-deps) в командной строке, или [опцию `quietDeps`](https://sass-lang.com/documentation/js-api/interfaces/Options/#quietDeps) в JavaScript API.

Для целей этого флага «зависимость» — это любая таблица стилей, которая не является просто серией относительных загрузок из входной таблицы стилей. Это означает всё, что поступает из пути загрузки, и большинство таблиц стилей, загруженных через пользовательские импортеры.

### Отключение конкретных устареваний {#silencing-specific-deprecations}

Если вы знаете, что одно конкретное устаревание не является для вас проблемой, вы можете отключить предупреждения для этого конкретного устаревания, используя [флаг `--silence-deprecation`](../cli/dart-sass/#silence-deprecation) в командной строке, или [опцию `silenceDeprecations`](https://sass-lang.com/documentation/js-api/interfaces/Options/#silenceDeprecations) в JavaScript API.
