---
title: Мигратор
icon: lucide/folder-input
---

> Мигратор Sass автоматически обновляет ваши файлы Sass, помогая перейти на последнюю версию языка. Каждая из его команд мигрирует отдельную функцию, что даёт вам максимальный контроль над тем, что обновлять и когда.

## Использование {#usage}

Чтобы использовать мигратор Sass, укажите ему, [какую миграцию](#migrations) вы хотите выполнить, и какие файлы Sass вы хотите мигрировать:

```sh
sass-migrator <migration> <entrypoint.scss...>
```

По умолчанию мигратор изменяет только те файлы, которые вы явно указали в командной строке. Передача опции [`--migrate-deps`](#migrate-deps) указывает мигратору также изменить все таблицы стилей, которые загружаются с помощью правила [`@use`](../at-rules/use), правила [`@forward`](../at-rules/forward) или правила [`@import`](../at-rules/import). А если вы хотите выполнить тестовый прогон, чтобы увидеть, какие изменения будут внесены, без их фактического сохранения, вы можете передать `[--dry-run](#dry-run) [--verbose](#verbose)` (или `-nv` для краткости).

```sh
$ cat style.scss
$body-bg: #000;
$body-color: #111;

@import "bootstrap";

@include media-breakpoint-up(sm) {
  .navbar {
    display: block;
  }
}
$ sass-migrator --migrate-deps module style.scss
$ cat style.scss
@use "bootstrap" with (
  $body-bg: #000,
  $body-color: #111
);

@include bootstrap.media-breakpoint-up(sm) {
  .navbar {
    display: block;
  }
}
```

## Установка {#installation}

Вы можете установить мигратор Sass из большинства тех же мест, откуда можно установить [Dart Sass](/):

### Автономная версия {#standalone}

Вы можете установить мигратор Sass на Windows, Mac или Linux, загрузив пакет для вашей операционной системы [с GitHub](https://github.com/sass/migrator/releases) и [добавив его в `PATH`](https://katiek2.github.io/path-doc/).

### npm

Если вы используете Node.js, вы также можете установить мигратор Sass с помощью [npm](https://www.npmjs.com), выполнив

```sh
npm install -g sass-migrator
```

### Chocolatey

Если вы используете [менеджер пакетов Chocolatey](https://chocolatey.org) для Windows, вы можете установить мигратор Sass, выполнив команду

```sh
choco install sass-migrator
```

### Homebrew

Если вы используете [менеджер пакетов Homebrew](https://brew.sh) для Mac OS X, вы можете установить Dart Sass, выполнив команду

```sh
brew install sass/sass/migrator
```

## Глобальные опции {#global-options}

Эти опции доступны для всех миграторов.

### `--migrate-deps` {#migrate-deps}

Эта опция (сокращённо `-d`) указывает мигратору изменять не только таблицы стилей, которые явно переданы в командной строке, но также любые таблицы стилей, от которых они зависят, используя [правило `@use`](../at-rules/use), [правило `@forward`](../at-rules/forward) или [правило `@import`](../at-rules/import).

```sh
$ sass-migrator module --verbose style.scss
Migrating style.scss
$ sass-migrator module --verbose --migrate-deps style.scss
Migrating style.scss
Migrating _theme.scss
Migrating _fonts.scss
Migrating _grid.scss
```

!!! note "Примечание"

    [Мигратор модулей](#module) предполагает, что любая таблица стилей, от которой зависят с помощью [правила `@use`](../at-rules/use) или [правила `@forward`](../at-rules/forward), уже перенесена в модульную систему, поэтому он не будет пытаться мигрировать их, даже если передана опция `--migrate-deps`.

### `--load-path` {#load-path}

Эта опция (сокращённо `-I`) указывает мигратору [путь загрузки](../at-rules/use#load-paths), в котором он должен искать таблицы стилей. Её можно передавать несколько раз, чтобы указать несколько путей загрузки. Более ранние пути загрузки будут иметь приоритет над более поздними.

Зависимости, загружаемые из путей загрузки, считаются сторонними библиотеками, поэтому мигратор не будет мигрировать их, даже если передана [опция `--migrate-deps`](#migrate-deps).

### `--dry-run` {#dry-run}

Этот флаг (сокращённо `-n`) указывает мигратору не сохранять никакие изменения на диск. Вместо этого он выводит список файлов, которые были бы изменены. Обычно это используется вместе с [опцией `--verbose`](#verbose) для вывода содержимого изменений, которые были бы сделаны.

```sh
$ sass-migrator module --dry-run --migrate-deps style.scss
Dry run. Logging migrated files instead of overwriting...

style.scss
_theme.scss
_fonts.scss
_grid.scss
```

#### `--no-unicode` {#no-unicode}

Этот флаг указывает мигратору Sass выводить в терминал только ASCII-символы в рамках сообщений об ошибках. По умолчанию или если передан флаг `--unicode`, мигратор будет выводить не-ASCII символы для этих сообщений. Этот флаг не влияет на вывод CSS.

```sh
$ sass-migrator --no-unicode module style.scss
line 1, column 9 of style.scss: Error: Could not find Sass file at 'typography'.
  ,
1 | @import "typography";
  |         ^^^^^^^^^^^^
  '
Migration failed!
$ sass-migrator --unicode module style.scss
line 1, column 9 of style.scss: Error: Could not find Sass file at 'typography'.
  ╷
1 │ @import "typography";
  │         ^^^^^^^^^^^^
  ╵
Migration failed!
```

### `--verbose` {#verbose}

Этот флаг (сокращённо `-v`) указывает мигратору выводить дополнительную информацию в консоль. По умолчанию он просто выводит имена изменённых файлов, но в сочетании с [опцией `--dry-run`](#dry-run) он также выводит новое содержимое этих файлов.

```sh
$ sass-migrator module --verbose --dry-run style.scss
Dry run. Logging migrated files instead of overwriting...
<==> style.scss
@use "bootstrap" with (
  $body-bg: #000,
  $body-color: #111
);

@include bootstrap.media-breakpoint-up(sm) {
  .navbar {
    display: block;
  }
}
$ sass-migrator module --verbose style.scss
Migrating style.scss
```

## Миграции {#migrations}

### `if()`

Эта миграция преобразует устаревшую функцию `if()` в новый синтаксис CSS `if()`. Подробности см. [здесь](../breaking-changes/if-function).

### Color {#color}

Эта миграция преобразует устаревшие цветовые функции в новые функции, совместимые с цветовыми пространствами.

### Division {#division}

Эта миграция преобразует таблицы стилей, использующие [`/` как деление](../breaking-changes/slash-div), чтобы вместо этого использовать встроенную функцию `math.div`.

#### `--pessimistic` {#pessimistic}

По умолчанию мигратор преобразует операции `/` в `math.div`, даже если не уверен, что это будет деление при вычислении. Он оставляет их как есть только тогда, когда может статически определить, что они делают что-то другое (например, когда не задействован SassScript или когда один из операндов является строкой). Функция `math.div` в настоящее время функционирует идентично оператору `/`, поэтому это безопасно, но может привести к новым предупреждениям, если один из аргументов `math.div` во время выполнения не является числом.

Если вы хотите избежать такого поведения, можно передать флаг `--pessimistic`. С этим флагом мигратор будет преобразовывать только те операции `/`, которые, как он точно знает, выполняют деление. Это предотвратит любые ненужные преобразования в `math.div`, но, вероятно, оставит некоторые деления немигрированными, если они не могут быть статически определены.

### Module {#module}

Эта миграция преобразует таблицы стилей, использующие старое [правило `@import`](../at-rules/import) для загрузки зависимостей, чтобы они использовали модульную систему Sass через [правило `@use`](../at-rules/use). Она не просто наивно заменяет `@import` на `@use` — она интеллектуально обновляет таблицы стилей так, чтобы они продолжали работать так же, как раньше, включая:

- Добавление пространств имён к использованию элементов (переменных, миксинов и функций) из других модулей.

- Добавление новых правил `@use` в таблицы стилей, которые использовали элементы без их импорта.

- Преобразование переопределённых переменных по умолчанию в [блоки `with`](../at-rules/use#configuration).

- Автоматическое удаление префиксов `-` и `_` из элементов, используемых из других файлов (потому что иначе они считались бы [приватными](../at-rules/use#private-members) и могли бы использоваться только в модуле, где они объявлены).

- Преобразование [вложенных импортов](../at-rules/import/#nesting) для использования [миксина `meta.load-css()`](../modules/meta#load-css).

!!! tip "Совет"

    Поскольку мигратору модулей может потребоваться изменить как определения элементов, _так и_ их имена, важно либо запустить его с [опцией `--migrate-deps`](#migrate-deps), либо убедиться, что вы передаёте ему все таблицы стилей в вашем пакете или приложении.

```sh
$ cat style.scss
$body-bg: #000;
$body-color: #111;

@import "bootstrap";

@include media-breakpoint-up(sm) {
  .navbar {
    display: block;
  }
}
$ sass-migrator --migrate-deps module style.scss
$ cat style.scss
@use "bootstrap" with (
  $body-bg: #000,
  $body-color: #111
);

@include bootstrap.media-breakpoint-up(sm) {
  .navbar {
    display: block;
  }
}
```

#### Загрузка зависимостей {#loading-dependencies}

Мигратору модулей необходимо иметь возможность читать все таблицы стилей, от которых зависят мигрируемые таблицы, даже если [опция `--migrate-deps`](#migrate-deps) не передана. Если мигратор не сможет найти зависимость, вы получите ошибку.

```sh
$ ls .
style.scss  node_modules
$ sass-migrator module style.scss
Error: Could not find Sass file at 'dependency'.
  ,
1 | @import "dependency";
  |         ^^^^^^^^^^^^
  '
  style.scss 1:9  root stylesheet
Migration failed!
$ sass-migrator --load-path node_modules module style.scss
```

Если вы используете [путь загрузки](../at-rules/use#load-paths) при компиляции ваших таблиц стилей, обязательно передайте его мигратору с помощью [опции `--load-path`](#load-path).

К сожалению, мигратор не поддерживает пользовательские импортёры, но имеет встроенную поддержку разрешения URL, начинающихся с `~`, путём поиска в `node_modules`, аналогично [тому, что поддерживает Webpack](https://github.com/webpack-contrib/sass-loader#resolving-import-at-rules).

#### `--remove-prefix` {#remove-prefix}

Эта опция (сокращённо `-p`) принимает префикс идентификатора для удаления из начала всех имён переменных, миксинов и функций при их миграции. Элементы, которые не начинаются с этого префикса, останутся без изменений.

[Правило `@import`](../at-rules/import) помещало все элементы верхнего уровня в одну глобальную область видимости, поэтому когда оно было стандартным способом загрузки таблиц стилей, все были мотивированы добавлять префиксы ко всем именам своих элементов, чтобы избежать случайного переопределения элементов из другой таблицы стилей. Модульная система решает эту проблему, поэтому полезно автоматически удалить эти старые префиксы, теперь, когда они больше не нужны.

```sh
$ cat style.scss
@import "theme";

@mixin app-inverted {
  color: $app-bg-color;
  background-color: $app-color;
}
$ sass-migrator --migrate-deps module --remove-prefix=app- style.scss
$ cat style.scss
@use "theme";

@mixin inverted {
  color: theme.$bg-color;
  background-color: theme.$color;
}
```

Когда вы передаёте эту опцию, мигратор также создаст [таблицу стилей только для импорта](../at-rules/import/#import-only-files), которая [перенаправляет](../at-rules/forward) все элементы с добавленным обратно префиксом, чтобы сохранить обратную совместимость для пользователей, которые импортировали библиотеку.

Эту опцию можно передавать несколько раз или с несколькими значениями, разделёнными запятыми. Каждый префикс будет удалён из всех элементов, которые его имеют. Если элемент соответствует нескольким префиксам, будет удалён самый длинный совпадающий префикс.

#### `--forward` {#forward}

Эта опция указывает мигратору, какие элементы перенаправлять с использованием [правила `@forward`](../at-rules/forward). Она поддерживает следующие настройки:

- `none` (по умолчанию) не перенаправляет никакие элементы.

- `all` перенаправляет все элементы, кроме тех, которые начинались с `-` или `_` в исходной таблице стилей, поскольку это обычно использовалось для обозначения приватных элементов пакета до введения модульной системы.

- `prefixed` перенаправляет только элементы, которые начинаются с префикса, переданного в [опцию `--remove-prefix`](#remove-prefix). Эта опция может использоваться только вместе с опцией `--remove-prefix`.

Все файлы, которые явно переданы в командной строке, будут перенаправлять элементы, транзитивно загруженные этими файлами с использованием правила `@import`. Файлы, загруженные с использованием [опции `--migrate-deps`](#migrate-deps), не будут перенаправлять новые элементы. Эта опция особенно полезна при миграции библиотеки Sass, поскольку гарантирует, что пользователи этой библиотеки по-прежнему смогут получить доступ ко всем определённым в ней элементам.

```sh
$ cat _index.scss
@import "theme";
@import "typography";
@import "components";
$ sass-migrator --migrate-deps module --forward=all style.scss
$ cat _index.scss
@forward "theme";
@forward "typography";
@forward "components";
```

### Namespace {#namespace}

Эта миграция позволяет легко изменять [пространства имён](../at-rules/use#choosing-a-namespace) правил `@use` в таблице стилей. Это полезно, если пространства имён, которые генерирует мигратор модулей для разрешения конфликтов, не идеальны, или если вы не хотите использовать пространство имён по умолчанию, которое Sass определяет на основе URL правила.

#### `--rename` {#rename}

Вы можете указать мигратору, какие пространства имён вы хотите изменить, передав выражения в опцию `--rename`.

Эти выражения имеют вид `<old-namespace> to <new-namespace>` или `url <rule-url> to <new-namespace>`. В этих выражениях `<old-namespace>` и `<rule-url>` являются [регулярными выражениями](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), которые сопоставляются с полным существующим пространством имён или URL правила `@use` соответственно.

В простых случаях это выглядит как `--rename 'old to new'`, что переименует правило `@use` с пространством имён `old` в `new`.

Однако вы также можете использовать это для выполнения более сложных переименований. Например, предположим, что у вас ранее была таблица стилей, которая выглядела так:

```scss
@import 'components/button/lib/mixins';
@import 'components/input/lib/mixins';
@import 'components/table/lib/mixins';
// ...
```

Поскольку все эти URL будут иметь пространство имён по умолчанию `mixins` при миграции на правила `@use`, мигратор модулей может в итоге сгенерировать что-то вроде этого:

```scss
@use 'components/button/lib/mixins' as button-lib-mixins;
@use 'components/input/lib/mixins' as input-lib-mixins;
@use 'components/table/lib/mixins' as table-lib-mixins;
// ...
```

Это валидный код, поскольку пространства имён не конфликтуют, но они намного сложнее, чем нужно. Релевантной частью URL является имя компонента, поэтому мы можем использовать мигратор пространств имён, чтобы извлечь эту часть.

Если мы запустим мигратор пространств имён с `--rename 'url components/(\w+)/lib/mixins to \1'`, мы получим:

```scss
@use 'components/button/lib/mixins' as button;
@use 'components/input/lib/mixins' as input;
@use 'components/table/lib/mixins' as table;
// ...
```

Скрипт переименования здесь указывает найти все правила `@use`, URL которых выглядят как `components/(\w+)/lib/mixins` (`\w+` в регулярном выражении означает соответствие любому слову из одного или более символов). `\1` в выходной части означает подставить содержимое первого набора скобок в регулярном выражении (называется [группой](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)).

Если вы хотите применить несколько переименований, вы можете передать опцию `--rename` несколько раз или разделить их точкой с запятой или переводом строки. Будет использовано только первое переименование, применимое к данному правилу, поэтому вы можете передать что-то вроде `--rename 'a to b; b to a'`, чтобы поменять местами пространства имён `a` и `b`.

#### `--force` {#force}

По умолчанию, если два или более правил `@use` имеют одинаковое пространство имён после миграции, мигратор завершится с ошибкой, и никакие изменения не будут внесены.

В этом случае обычно вы захотите скорректировать свой скрипт `--rename`, чтобы избежать создания конфликтов, но если вы предпочитаете принудительно выполнить миграцию, то можно передать `--force`.

При использовании `--force`, если возникают конфликты, первое правило `@use` получит своё предпочитаемое пространство имён, в то время как последующие правила `@use` с таким же предпочитаемым пространством имён получат числовой суффикс.
