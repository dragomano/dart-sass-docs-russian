---
title: "@extend"
icon: lucide/at-sign
---

> При проектировании страницы часто возникают ситуации, когда один класс должен иметь все стили другого класса, а также свои собственные специфические стили. Например, [методология BEM](https://getbem.com/naming/) рекомендует использовать классы-модификаторы, которые применяются к тем же элементам, что и классы блока или элемента. Но это может привести к загромождённому HTML, повышает вероятность ошибок из-за забытого включения обоих классов и может привносить несемантические стилевые аспекты в вашу разметку.

```html
<div class="error error--serious">
  О нет! Вас взломали!
</div>
```

```css
.error {
  border: 1px #f00;
  background-color: #fdd;
}

.error--serious {
  border-width: 3px;
}
```

Правило Sass `@extend` решает эту проблему. Оно записывается как `@extend <селектор>` и указывает Sass, что один селектор должен унаследовать стили другого.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    .error {
      border: 1px #f00;
      background-color: #fdd;

      &--serious {
        @extend .error;
        border-width: 3px;
      }
    }
    ```

=== "SASS"

    ```sass
    .error
      border: 1px #f00
      background-color: #fdd

      &--serious
        @extend .error
        border-width: 3px
    ```

```css title="CSS"
.error, .error--serious {
  border: 1px #f00;
  background-color: #fdd;
}
.error--serious {
  border-width: 3px;
}
```

</div>

Когда один класс расширяет другой, Sass стилизует все элементы, соответствующие расширяющему классу, так, как если бы они также соответствовали расширяемому классу. Когда один селектор класса расширяет другой, это работает точно так же, как если бы вы добавили расширяемый класс к каждому элементу в вашем HTML, который уже имеет расширяющий класс. Вы можете просто написать `class="error--serious"`, и Sass гарантирует, что он будет стилизован так, как если бы он также имел `class="error"`.

Конечно, селекторы используются не только сами по себе в стилевых правилах. Sass знает, как расширить селектор *везде*, где он используется. Это гарантирует, что ваши элементы будут стилизованы точно так же, как если бы они соответствовали расширяемому селектору.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    .error:hover {
      background-color: #fee;
    }

    .error--serious {
      @extend .error;
      border-width: 3px;
    }
    ```

=== "SASS"

    ```sass
    .error:hover
      background-color: #fee

    .error--serious
      @extend .error
      border-width: 3px
    ```

```css title="CSS"
.error:hover, .error--serious:hover {
  background-color: #fee;
}

.error--serious {
  border-width: 3px;
}
```

</div>

!!! note "Примечание"

    Расширения разрешаются после компиляции остальной части вашей таблицы стилей. В частности, это происходит после разрешения [родительских селекторов](../style-rules/parent-selector). Это означает, что если вы используете `@extend .error`, это не повлияет на внутренний селектор в `.error { &__icon { ... } }`. Это также означает, что [родительские селекторы в SassScript](../style-rules/parent-selector#in-sassscript) не могут видеть результаты расширения.

## Как это работает {#how-it-works}

В отличие от [миксинов](../at-rules/mixin), которые копируют стили в текущее стилевое правило, `@extend` обновляет стилевые правила, содержащие расширяемый селектор, так, чтобы они также содержали расширяющий селектор. При расширении селекторов Sass выполняет *интеллектуальное объединение*:

* Он никогда не генерирует селекторы вроде `#main#footer`, которые не могут соответствовать никаким элементам.

* Он гарантирует, что сложные селекторы правильно чередуются, чтобы они работали независимо от порядка вложенности HTML-элементов.

* Он максимально сокращает избыточные селекторы, при этом гарантируя, что специфичность больше или равна специфичности расширяющего селектора.

* Он распознаёт, когда один селектор соответствует всему, чему соответствует другой, и может объединять их вместе.

* Он интеллектуально обрабатывает [комбинаторы](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators), [универсальные селекторы](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors) и [псевдоклассы, содержащие селекторы](https://developer.mozilla.org/en-US/docs/Web/CSS/:not).

<div class="grid" markdown>

=== "SCSS"

    ```scss
    .content nav.sidebar {
      @extend .info;
    }

    // Это не будет расширено, потому что `p` несовместим с `nav`.
    p.info {
      background-color: #dee9fc;
    }

    // Невозможно знать, будет ли `<div class="guide">` находиться внутри или
    // снаружи `<div class="content">`, поэтому Sass генерирует оба варианта для безопасности.
    .guide .info {
      border: 1px solid rgba(#000, 0.8);
      border-radius: 2px;
    }

    // Sass знает, что каждый элемент, соответствующий "main.content", также соответствует ".content"
    // и избегает генерации ненужных чередующихся селекторов.
    main.content .info {
      font-size: 0.8em;
    }
    ```

=== "SASS"

    ```sass
    .content nav.sidebar
      @extend .info

    // Это не будет расширено, потому что `p` несовместим с `nav`.
    p.info
      background-color: #dee9fc

    // Невозможно знать, будет ли `<div class="guide">` находиться внутри или
    // снаружи `<div class="content">`, поэтому Sass генерирует оба варианта для безопасности.
    .guide .info
      border: 1px solid rgba(#000, 0.8)
      border-radius: 2px

    // Sass знает, что каждый элемент, соответствующий "main.content", также соответствует ".content"
    // и избегает генерации ненужных чередующихся селекторов.
    main.content .info
      font-size: 0.8em
    ```

```css title="CSS"
p.info {
  background-color: #dee9fc;
}

.guide .info, .guide .content nav.sidebar, .content .guide nav.sidebar {
  border: 1px solid rgba(0, 0, 0, 0.8);
  border-radius: 2px;
}

main.content .info, main.content nav.sidebar {
  font-size: 0.8em;
}
```

</div>

!!! tip "Совет"

    Вы можете напрямую использовать интеллектуальное объединение Sass с помощью [функций для работы с селекторами](../modules/selector)! Функция [`selector.unify()`](../modules/selector#unify) возвращает селектор, который соответствует пересечению двух селекторов, а функция [`selector.extend()`](../modules/selector#extend) работает так же, как `@extend`, но для одного селектора.

!!! note "Примечание"

    Поскольку `@extend` обновляет стилевые правила, содержащие расширяемый селектор, их стили имеют приоритет в [каскаде](https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade) на основе того, где появляются стилевые правила расширяемого селектора, а *не* на основе того, где появляется `@extend`. Это может сбивать с толку, но помните: это тот же приоритет, который эти правила имели бы, если бы вы добавили расширяемый класс в ваш HTML!

## Селекторы-заполнители {#placeholder-selectors}

Иногда вам нужно написать стилевое правило, которое предназначено *только* для расширения. В этом случае вы можете использовать [селекторы-заполнители](../style-rules/placeholder-selectors), которые выглядят как селекторы классов, но начинаются с `%` вместо `.`. Любые селекторы, которые включают заполнители, не включаются в CSS-вывод, но селекторы, которые их расширяют, включаются.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    .alert:hover, %strong-alert {
      font-weight: bold;
    }

    %strong-alert:hover {
      color: red;
    }
    ```

=== "SASS"

    ```sass
    .alert:hover, %strong-alert
      font-weight: bold

    %strong-alert:hover
      color: red
    ```

```css title="CSS"
.alert:hover {
  font-weight: bold;
}
```

</div>

### Приватные заполнители {#private-placeholders}

Как и [элементы модуля](../at-rules/use#private-members), селектор-заполнитель может быть помечен как приватный, если его имя начинается с `-` или `_`. Приватный селектор-заполнитель может быть расширен только в пределах таблицы стилей, которая его определяет. Для любых других таблиц стилей он будет выглядеть так, как будто этот селектор не существует.

## Область видимости расширения {#extension-scope}

Когда одна таблица стилей расширяет селектор, это расширение будет влиять только на стилевые правила, написанные в *вышестоящих* модулях — то есть модулях, которые загружаются этой таблицей стилей с помощью [правила `@use`](../at-rules/use) или [правила `@forward`](../at-rules/forward), модулях, загруженных *этими* модулями, и так далее. Это помогает сделать ваши правила `@extend` более предсказуемыми, гарантируя, что они влияют только на те стили, о которых вы знали при их написании.

!!! warning "Предупреждение"

    Расширения не имеют области видимости вообще, если вы используете [правило `@import`](../at-rules/import). Они не только будут влиять на каждую таблицу стилей, которую вы импортируете, но и на каждую таблицу стилей, которая импортирует вашу таблицу стилей, на всё остальное, что импортируют эти таблицы стилей, и так далее. Без `@use` расширения являются *глобальными*.

## Обязательные и необязательные расширения {#mandatory-and-optional-extends}

Обычно, если `@extend` не соответствует никаким селекторам в таблице стилей, Sass выдаст ошибку. Это помогает защититься от опечаток или от переименования селектора без переименования селекторов, которые от него наследуют. Расширения, которые требуют существования расширяемого селектора, являются *обязательными*.

Однако это не всегда может быть тем, что вы хотите. Если вы хотите, чтобы `@extend` ничего не делал, если расширяемый селектор не существует, просто добавьте `!optional` в конец.

## Расширения или миксины? {#extends-or-mixins}

Расширения и [миксины](../at-rules/mixin) — это два способа инкапсуляции и повторного использования стилей в Sass, что естественно поднимает вопрос о том, когда использовать каждый из них. Миксины, очевидно, необходимы, когда вам нужно настроить стили с помощью [аргументов](../at-rules/mixin/#arguments), но что если это просто набор стилей?

Как правило, расширения являются лучшим вариантом, когда вы выражаете отношение между семантическими классами (или другими семантическими селекторами). Поскольку элемент с классом `.error--serious` *является* ошибкой, логично, чтобы он расширял `.error`. Но для несемантических наборов стилей написание миксина может избежать проблем с каскадом и упростить настройку в будущем.

!!! tip "Совет"

    Большинство веб-серверов сжимают CSS, который они отдают, используя алгоритм, который очень хорошо справляется с повторяющимися фрагментами идентичного текста. Это означает, что хотя миксины могут производить больше CSS, чем расширения, они, вероятно, не увеличат существенно объём данных, который вашим пользователям нужно загрузить. Поэтому выбирайте функцию, которая наиболее подходит для вашего случая использования, а не ту, которая генерирует меньше CSS!

## Ограничения {#limitations}

### Запрещённые селекторы {#disallowed-selectors}

Только *простые селекторы* — отдельные селекторы вроде `.info` или `a` — могут быть расширены. Если бы `.message.info` мог быть расширен, определение `@extend` говорит, что элементы, соответствующие расширяющему селектору, будут стилизованы так, как если бы они соответствовали `.message.info`. Это то же самое, что соответствовать и `.message`, и `.info`, поэтому не было бы никакой пользы от написания этого вместо `@extend .message, .info`.

Аналогично, если бы `.main .info` мог быть расширен, это сделало бы (почти) то же самое, что и расширение `.info` само по себе. Тонкие различия не стоят путаницы от того, что выглядит так, как будто делается что-то существенно иное, поэтому это тоже не разрешено.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    .alert {
      @extend .message.info;
      //      ^^^^^^^^^^^^^
      // Ошибка: пишите `@extend .message, .info` вместо этого.

      @extend .main .info;
      //      ^^^^^^^^^^^
      // Ошибка: пишите `@extend .info` вместо этого.
    }
    ```

=== "SASS"

    ```sass
    .alert
      @extend .message.info
      //      ^^^^^^^^^^^^^
      // Ошибка: пишите `@extend .message, .info` вместо этого.

      @extend .main .info
      //      ^^^^^^^^^^^
      // Ошибка: пишите `@extend .info` вместо этого.
    ```

</div>

### HTML-эвристики {#html-heuristics}

Когда `@extend` [чередует сложные селекторы](#how-it-works), оно не генерирует все возможные комбинации селекторов-предков. Многие из селекторов, которые оно могло бы сгенерировать, вряд ли будут соответствовать реальному HTML, и их генерация сделала бы таблицы стилей слишком большими при очень малой практической ценности. Вместо этого оно использует [эвристику](https://en.wikipedia.org/wiki/Heuristic), предполагая, что предки каждого селектора будут самодостаточными, без чередования с предками любого другого селектора.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    header .warning li {
      font-weight: bold;
    }

    aside .notice dd {
      // Sass не генерирует CSS для соответствия <dd> в
      //
      // <header>
      //   <aside>
      //     <div class="warning">
      //       <div class="notice">
      //         <dd>...</dd>
      //       </div>
      //     </div>
      //   </aside>
      // </header>
      //
      // потому что соответствие всем таким элементам потребовало бы от нас
      // генерации девяти новых селекторов вместо всего двух.
      @extend li;
    }
    ```

=== "SASS"

    ```sass
    header .warning li
      font-weight: bold

    aside .notice dd
      // Sass не генерирует CSS для соответствия <dd> в
      //
      // <header>
      //   <aside>
      //     <div class="warning">
      //       <div class="notice">
      //         <dd>...</dd>
      //       </div>
      //     </div>
      //   </aside>
      // </header>
      //
      // потому что соответствие всем таким элементам потребовало бы от нас
      // генерации девяти новых селекторов вместо всего двух.
      @extend li
    ```

```css title="CSS"
header .warning li, header .warning aside .notice dd, aside .notice header .warning dd {
  font-weight: bold;
}
```

</div>

### Extend в `@media` {#extend-in-media}

Хотя `@extend` разрешён внутри [`@media` и других at-правил CSS](../at-rules/css), не разрешается расширять селекторы, которые находятся вне его at-правила. Это связано с тем, что расширяющий селектор применяется только в заданном медиа-контексте, и нет способа гарантировать сохранение этого ограничения в сгенерированном селекторе без дублирования всего стилевого правила.

<div class="grid" markdown>

=== "SCSS"

    ```scss
    @media screen and (max-width: 600px) {
      .error--serious {
        @extend .error;
        //      ^^^^^^
        // Ошибка: ".error" был расширен в @media, но использован вне его.
      }
    }

    .error {
      border: 1px #f00;
      background-color: #fdd;
    }
    ```

=== "SASS"

    ```sass
    @media screen and (max-width: 600px)
      .error--serious
        @extend .error
        //      ^^^^^^
        // Ошибка: ".error" был расширен в @media, но использован вне его.

    .error
      border: 1px #f00
      background-color: #fdd
    ```

</div>
